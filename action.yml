name: 'ESP-IDF Size Delta'
description: 'Build ESP-IDF app and report FLASH and RAM deltas vs a base ref'
author: 'espp'

inputs:
  app_name:
    description: 'Name of the ESP-IDF app (for reporting)'
    required: true
  app_path:
    description: 'Relative path to the ESP-IDF app (contains CMakeLists.txt)'
    required: true
  idf_version:
    description: 'ESP-IDF version to setup'
    required: false
    default: 'v5.5'
  idf_target:
    description: 'ESP-IDF target (defaults to IDF_TARGET env var or "esp32")'
    required: false
  idf_component_manager:
    description: 'Set IDF_COMPONENT_MANAGER ("0" to disable)'
    required: false
    default: '0'
  head_name:
    description: 'Name of the head app (for reporting, defaults to "PR")'
    required: false
    default: 'PR'
  base_name:
    description: 'Name of the base app (for reporting, defaults to "Base")'
    required: false
    default: 'Base'
  base_ref:
    description: 'Git ref/sha to use as base for delta (defaults to PR base sha)'
    required: false
  post_comment:
    description: 'Whether to post a PR comment (true/false)'
    required: false
    default: 'true'
  flash_total_override:
    description: 'Override total FLASH bytes for percentage (optional)'
    required: false
    default: ''
  github_token:
    description: 'GitHub token'
    required: false
    default: ${{ github.token }}
  checkout_token:
    description: 'Token to use for checkout actions (defaults to GITHUB_TOKEN)'
    required: false
    default: ''

outputs:
  markdown:
    description: 'Markdown report for this app'
    value: ${{ steps.mkdown.outputs.markdown }}

runs:
  using: 'composite'
  steps:
    - name: Set up Python
      uses: actions/setup-python@v5
      id: id_python_313
      with:
        python-version: '3.13'

    - name: Checkout HEAD
      uses: actions/checkout@v5
      with:
        submodules: 'recursive'
        token: ${{ inputs.checkout_token || github.token }}
        path: head
        fetch-depth: 0

    - name: Build (HEAD)
      uses: espressif/esp-idf-ci-action@v1
      with:
        esp_idf_version: ${{ inputs.idf_version }}
        target: ${{ inputs.idf_target }}
        path: head/${{ inputs.app_path }}
        command: |
          set IDF_COMPONENT_MANAGER=${{ inputs.idf_component_manager }}
          idf.py size --format json2 --output-file idf_size.json

    - name: Process size (HEAD)
      shell: bash
      run:
        python ${{ github.action_path }}/idf_size_report.py --in-file head/${{ inputs.app_path }}/idf_size.json --out-file head_size.json --flash-total-override "${{ inputs.flash_total_override }}" || echo '{"flash":0,"dram":0,"iram":0,"ram":0}' > head_size.json

    # delete the head directory
    - name: Clean up head directory
      shell: bash
      run: |
        sudo chown -R $USER:$USER head
        rm -rf head

    - name: Determine base ref
      id: determine_base_ref
      shell: bash
      run: |
        base_ref="${{ inputs.base_ref }}"
        base_name="${{ inputs.base_name }}"
        head_name="${{ inputs.head_name }}"
        
        # If no base_ref provided, try to determine it automatically
        if [ -z "$base_ref" ]; then
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            base_ref="${{ github.event.pull_request.base.sha }}"
            echo "Auto-detected base_ref from PR: $base_ref"
          elif [ "${{ github.event_name }}" = "release" ] && [ "${{ github.event.action }}" = "published" ]; then
            # For releases, find the previous tag chronologically
            echo "Release detected, finding previous tag..."
            # Fetch all tags to ensure we have complete tag history
            git fetch --tags --force || echo "Warning: Could not fetch tags, using local tag history"
            
            current_tag="${{ github.event.release.tag_name }}"
            echo "Current release tag: $current_tag"
            
            # Auto-set head_name to current tag if not already specified
            if [ "$head_name" = "PR" ]; then
              head_name="$current_tag"
            fi
            
            # Get all tags sorted by creation date (newest first), exclude current tag
            prev_tag=$(git --no-pager tag --sort=-creatordate | grep -v "^${current_tag}$" | head -n1 || true)
            
            # If that doesn't work, try version sorting as fallback
            if [ -z "$prev_tag" ]; then
              prev_tag=$(git --no-pager tag --sort=-version:refname | grep -v "^${current_tag}$" | head -n1 || true)
            fi
            
            if [ -n "$prev_tag" ]; then
              base_ref="$prev_tag"
              # Auto-set base_name to the tag if not already specified
              if [ "$base_name" = "Base" ]; then
                base_name="$prev_tag"
              fi
              echo "Found previous tag: $prev_tag"
            else
              echo "No previous tag found for release comparison"
            fi
          fi
        fi
        
        echo "base_ref=$base_ref" >> $GITHUB_OUTPUT
        echo "base_name=$base_name" >> $GITHUB_OUTPUT
        echo "head_name=$head_name" >> $GITHUB_OUTPUT
        if [ -n "$base_ref" ]; then
          echo "has_base_ref=true" >> $GITHUB_OUTPUT
          echo "Using base_ref: $base_ref (base_name: $base_name)"
        else
          echo "has_base_ref=false" >> $GITHUB_OUTPUT
          echo "No base_ref - will generate size-only report"
        fi
        echo "Using head_name: $head_name"

    - name: Checkout BASE
      if: ${{ steps.determine_base_ref.outputs.has_base_ref == 'true' }}
      uses: actions/checkout@v5
      with:
        ref: ${{ steps.determine_base_ref.outputs.base_ref }}
        submodules: 'recursive'
        token: ${{ inputs.checkout_token || github.token }}
        path: base
        fetch-depth: 0

    - name: Build (BASE)
      if: ${{ steps.determine_base_ref.outputs.has_base_ref == 'true' }}
      uses: espressif/esp-idf-ci-action@v1
      with:
        esp_idf_version: ${{ inputs.idf_version }}
        target: ${{ inputs.idf_target }}
        path: base/${{ inputs.app_path }}
        command: |
          set IDF_COMPONENT_MANAGER=${{ inputs.idf_component_manager }}
          idf.py size --format json2 --output-file idf_size.json

    - name: Process size (BASE)
      if: ${{ steps.determine_base_ref.outputs.has_base_ref == 'true' }}
      shell: bash
      run:
        python ${{ github.action_path }}/idf_size_report.py --in-file base/${{ inputs.app_path }}/idf_size.json --out-file base_size.json --flash-total-override "${{ inputs.flash_total_override }}" || echo '{"flash":0,"dram":0,"iram":0,"ram":0}' > base_size.json

    - name: Create empty base size (no base ref)
      if: ${{ steps.determine_base_ref.outputs.has_base_ref == 'false' }}
      shell: bash
      run: |
        echo '{"flash":0,"dram":0,"iram":0,"ram":0}' > base_size.json

    # delete the base directory
    - name: Clean up base directory
      if: ${{ steps.determine_base_ref.outputs.has_base_ref == 'true' }}
      shell: bash
      run: |
        sudo chown -R $USER:$USER base
        rm -rf base

    - name: Make markdown
      id: mkdown
      shell: bash
      run: |
        # generate markdown
        if [ "${{ steps.determine_base_ref.outputs.has_base_ref }}" = "true" ]; then
          md=$(${{ steps.id_python_313.outputs.python-path }} ${{ github.action_path }}/render_markdown.py --app-name "${{ inputs.app_name }}" --base-name "${{ steps.determine_base_ref.outputs.base_name }}" --head-name "${{ steps.determine_base_ref.outputs.head_name }}" --head-json head_size.json --base-json base_size.json)
        else
          md=$(${{ steps.id_python_313.outputs.python-path }} ${{ github.action_path }}/render_markdown.py --app-name "${{ inputs.app_name }}" --head-name "${{ steps.determine_base_ref.outputs.head_name }}" --head-json head_size.json --no-base)
        fi
        # append to summary and set output
        echo "$md" >> "$GITHUB_STEP_SUMMARY"
        echo "markdown<<EOF" >> $GITHUB_OUTPUT
        echo "$md" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Comment on PR
      if: ${{ inputs.post_comment == 'true' && github.event_name == 'pull_request' }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const body = `${{ steps.mkdown.outputs.markdown }}`
          const {owner, repo, number} = context.issue;
          const appName = `${{ inputs.app_name }}`;
          const commentIdentifier = `<!-- esp-idf-size-delta:${appName} -->`;
          
          // Get existing comments
          const comments = await github.rest.issues.listComments({
            owner,
            repo,
            issue_number: number,
          });
          
          // Find existing comment with our identifier
          const existingComment = comments.data.find(comment => 
            comment.body && comment.body.includes(commentIdentifier)
          );
          
          if (existingComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: existingComment.id,
              body
            });
            console.log(`Updated existing comment ${existingComment.id}`);
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: number,
              body
            });
            console.log('Created new comment');
          }

    - name: Append to Release Notes (if Release)
      if: ${{ github.event.release && github.event.action == 'published' }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github_token }}
        script: |
          const addition = `${{ steps.mkdown.outputs.markdown }}`
          const {owner, repo} = context.repo;
          const release_id = context.payload.release.id;
          const current = context.payload.release.body || '';
          const body = [current, '', addition].filter(Boolean).join('\n');
          await github.rest.repos.updateRelease({ owner, repo, release_id, body });
